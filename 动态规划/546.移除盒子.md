## 546.移除盒子

给出一些不同颜色的盒子，盒子的颜色由数字表示，即不同的数字表示不同的颜色。
你将经过若干轮操作去去掉盒子，直到所有的盒子都去掉为止。每一轮你可以移除具有相同颜色的连续 k 个盒子（k >= 1），这样一轮之后你将得到 k*k 个积分。
当你将所有盒子都去掉之后，求你能获得的最大积分和。

示例 1：
输入:

```
[1, 3, 2, 2, 2, 3, 4, 3, 1]
```

输出:

```
23
```

解释:

```
[1, 3, 2, 2, 2, 3, 4, 3, 1] 
----> [1, 3, 3, 4, 3, 1] (3*3=9 分) 
----> [1, 3, 3, 3, 1] (1*1=1 分) 
----> [1, 1] (3*3=9 分) 
----> [] (2*2=4 分)
```

**提示：**盒子的总数 `n` 不会超过 100。

### 解题思路

一开始看到这道题目的时候，基本是没有什么思路的，于是就想先用暴力解法做一下。暴力解法的思路涉及到到递归的思想，也就是我们每次对给定长度的boxes随机移除某一个盒子，当然如果遇到连续盒子的话，就不断搜索它的边界，直到遇到一个不同的元素为止。有了这个思路，我们就可以先写一下暴力解法的代码。

#### 暴力解法

```python 
class Solution:
    def removeBoxes(self, boxes: List[int]) -> int:
        # 暴力解法
        def dfs(boxes):
            if not boxes:
                return 0
            if len(boxes) == 1:
                return 1

            score = 0
            left, right = 0, 0
            # 搜索连续相同元素的最大边界
            while(left < len(boxes)):
                right = left + 1
                while(right < len(boxes) and boxes[right] == boxes[left]):
                    right += 1
                
                score = max(score, dfs(boxes[0:left] + boxes[right:]) + (right - left)**2)
                left = right
            
            return score
        
        return dfs(boxes)
```

很明显上面的代码重复求解了很多问题，这样一定会超时的，让我们分析一下暴力解法的时间复杂度和空间复杂度。

- 时间复杂度：$O(N!)$
- 空间复杂度：$O(N^2)$

我做到这一步的时候，就开始想如何对上面的代码进行优化，去除冗余的重复计算。自己卡了很久之后没想出来，看了题解之后，重新整理一下思路。

### 方法



