## 932. 漂亮的数组

### 题目地址：

 https://leetcode-cn.com/problems/beautiful-array/ 

### 题目描述：

对于某些固定的 `N`，如果数组 `A` 是整数 `1, 2, ..., N` 组成的排列，使得：

对于每个 `i < j`，都**不存在** `k` 满足 `i < k < j` 使得 `A[k] * 2 = A[i] + A[j]`。

那么数组 `A` 是漂亮数组。

给定 `N`，返回**任意**漂亮数组 `A`（保证存在一个）。

**示例 1：**

```
输入：4
输出：[2,1,4,3]
```

**示例 2：**

```
输入：5
输出：[3,1,2,5,4]
```

**提示：**

- `1 <= N <= 1000`

### 思路：分治法

首先我们可以发现对于一个漂亮数组A，其具有如下性质：

- (k * A + b) 是一个漂亮数组，其中（k不为0）

- 2*A（数组中每个元素乘以2）也是漂亮数组
- 2*A - 1 也是漂亮数组

 满足下面条件的为漂亮数组：每个 i < j，都不存在 k 满足 i < k < j 使得 `A[k] * 2 = A[i] + A[j] `

- `A[k] * 2 ` 一定是一个偶数
- 等式右边由 ` A[i]` 和 `A[j]` 组成，如果  ` A[i]`  是奇数，`A[j]` 是偶数，则两部分相加的和为奇数，此时等式不成立。              
- 偶数 ≠ 奇数

 因此我们将所有的奇数放在 ` left  `部分，所有的偶数放在  `right`  部分，这样可以保证等式恒不成立。对于 [1..N] 的排列，`left`  部分包括 (N + 1) / 2 个奇数，`right`  部分包括 N / 2 个偶数。对于  `left`  部分，我们进行 k = 1/2, b = 1/2 的仿射变换，把这些奇数一一映射到不超过 (N + 1) / 2 的整数。对于  `right`  部分，我们进行 k = 1/2, b = 0 的仿射变换，把这些偶数一一映射到不超过 N / 2 的整数。经过映射，`left ` 和  `right ` 部分变成了和原问题一样，但规模减少一半的子问题，这样就可以使用分治算法解决了。

#### 代码实现：

```python
def beautifulArray(self, N):
    """
    :type N: int
    :rtype: List[int]
    """
    return self.merge(N)

def merge(self, N):
    memo = {1: [1]}
    if N not in memo:
        odds = self.merge((N+1)/2)
        evens = self.merge(N/2)
        memo[N] = [2*x-1 for x in odds] + [2*x for x in evens]
    return memo[N]
```

