## 53. 最大子序和

### 题目地址：

 https://leetcode-cn.com/problems/maximum-subarray/ 



###  题目描述：

给定一个整数数组 `nums` ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 

**示例:**

```none
输入: [-2,1,-3,4,-1,2,1,-5,4],
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
```

**进阶:**

如果你已经实现复杂度为 O(*n*) 的解法，尝试使用更为精妙的分治法求解。



###  思路

#### 方法一

采用分治算法来解这道题，对于输入的数组 `nums`，我们要寻找 `nums[low, high]` 的最大子数组。首先我们需要把数组划分为两个等规模的数组，也就是我们需要找到数组的中间位置 `mid`。`nums[low，high]` 的任何连续子数组 `nums[i，j]` 所处的位置必然满足下面三种情况：

- 完全位于子数组 `nums[low，mid]` 中，因此 `low<= i <= j <= mid`。
- 完全位于子数组 `nums[mid+1，high]` 中，因此 `mid<= i <= j <= high`。
- 跨越了中点，因此 `low<= i <= mid <= j <= high`。

 分别求出三种情况下最大子序列和，三者中最大值即为最大子序列和。 

#### 方法二

采用动态规划法，其特点在于对所有子问题只求解一次，并将结果保存下来。如果后续需要此子问题的解，只需要查找保存的结果，而不必重新计算。因此动态规划是付出额外的内存空间来节省计算时间。

适用于动态规划方法求解的最优化问题应该具备两个要素：最优子结构和子问题重叠。



### 代码：

#### 分治算法

```python
def maxSubArray(self, nums):
    """
    :type nums: List[int]
    :rtype: int
    """
    low = 0
    high = len(nums) - 1
    left, right, sum = self.FindMaxSubarray(nums, low, high)
    return sum

def FindMaxSubarray(self, nums, low, high):
    if high == low:
        return (low, high, nums[low])
    else:
        mid = (low+high)/2
        left_low, left_high, left_sum = \
            self.FindMaxSubarray(nums, low, mid)
        right_low, right_high, right_sum = \
            self.FindMaxSubarray(nums, mid+1, high)
        cross_low, cross_high, cross_sum = \
            self.FindMaxCrossSubarray(nums, low, mid, high)

        if left_sum >= right_sum and left_sum >= cross_sum:
            return(left_low, left_high, left_sum)
        elif right_sum >= left_sum and right_sum >= cross_sum:
            return(right_low, right_high, right_sum)
        else:
            return(cross_low, cross_high, cross_sum)

def FindMaxCrossSubarray(self, nums, low, mid, high):
    left_sum = -10000
    sum = 0
    for i in range(mid, low-1, -1):
        sum = sum + nums[i]
        if sum > left_sum:
            left_sum = sum
            max_left = i

    right_sum = -10000
    sum = 0
    for j in range(mid+1, high+1):
        sum = sum + nums[j]
        if sum > right_sum:
            right_sum = sum
            max_right = j
    
    return (max_left, max_right, left_sum + right_sum)
```



#### 动态规划法

```
def maxSubArray(self, nums):
    """
    :type nums: List[int]
    :rtype: int
    """  
    n = len(nums)
    max_temp_sum = max_sum = nums[0]
    for i in range(1, n):
        max_temp_sum = max(max_temp_sum + nums[i], nums[i]) 
        max_sum = max(max_temp_sum, max_sum)
    
    return max_sum
```



