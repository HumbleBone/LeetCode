## 53. 最大子序和

#### 题目地址：

 https://leetcode-cn.com/problems/maximum-subarray/ 

#### 题目描述：

> 给定一个整数数组 `nums` ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 
>
> **示例:**
>
> ```none
> 输入: [-2,1,-3,4,-1,2,1,-5,4],
> 输出: 6
> 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
> ```
>
> **进阶:**
>
> 如果你已经实现复杂度为 O(*n*) 的解法，尝试使用更为精妙的分治法求解。



#### 问题解答：

```python
def maxSubArray(self, nums):
    """
    :type nums: List[int]
    :rtype: int
    """
    low = 0
    high = len(nums) - 1
    left, right, sum = self.FindMaxSubarray(nums, low, high)
    return sum

def FindMaxSubarray(self, nums, low, high):
    if high == low:
        return (low, high, nums[low])
    else:
        mid = (low+high)/2
        left_low, left_high, left_sum = \
            self.FindMaxSubarray(nums, low, mid)
        right_low, right_high, right_sum = \
            self.FindMaxSubarray(nums, mid+1, high)
        cross_low, cross_high, cross_sum = \
            self.FindMaxCrossSubarray(nums, low, mid, high)

        if left_sum >= right_sum and left_sum >= cross_sum:
            return(left_low, left_high, left_sum)
        elif right_sum >= left_sum and right_sum >= cross_sum:
            return(right_low, right_high, right_sum)
        else:
            return(cross_low, cross_high, cross_sum)

def FindMaxCrossSubarray(self, nums, low, mid, high):
    left_sum = -10000
    sum = 0
    for i in range(mid, low-1, -1):
        sum = sum + nums[i]
        if sum > left_sum:
            left_sum = sum
            max_left = i

    right_sum = -10000
    sum = 0
    for j in range(mid+1, high+1):
        sum = sum + nums[j]
        if sum > right_sum:
            right_sum = sum
            max_right = j
    
    return (max_left, max_right, left_sum + right_sum)
```



