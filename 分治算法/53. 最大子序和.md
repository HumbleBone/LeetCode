## 53. 最大子序和

```python 
    def maxSubArray(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        low = 0
        high = len(nums) - 1
        left, right, sum = self.FindMaxSubarray(nums, low, high)
        return sum

    def FindMaxSubarray(self, nums, low, high):
        if high == low:
            return (low, high, nums[low])
        else:
            mid = (low+high)/2
            left_low, left_high, left_sum = \
                self.FindMaxSubarray(nums, low, mid)
            right_low, right_high, right_sum = \
                self.FindMaxSubarray(nums, mid+1, high)
            cross_low, cross_high, cross_sum = \
                self.FindMaxCrossSubarray(nums, low, mid, high)

            if left_sum >= right_sum and left_sum >= cross_sum:
                return(left_low, left_high, left_sum)
            elif right_sum >= left_sum and right_sum >= cross_sum:
                return(right_low, right_high, right_sum)
            else:
                return(cross_low, cross_high, cross_sum)
    
    def FindMaxCrossSubarray(self, nums, low, mid, high):
        left_sum = -10000
        sum = 0
        for i in range(mid, low-1, -1):
            sum = sum + nums[i]
            if sum > left_sum:
                left_sum = sum
                max_left = i

        right_sum = -10000
        sum = 0
        for j in range(mid+1, high+1):
            sum = sum + nums[j]
            if sum > right_sum:
                right_sum = sum
                max_right = j
        
        return (max_left, max_right, left_sum + right_sum)  
```

